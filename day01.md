

###  函数重载的本质
- c++编译器默认会对符号名（函数名、变量名）进行改编、修饰。重载时会生成多个不同名称的函数；所以支持重载。

###  extern "C" 
- 可以在c++文件中让某个函数按照c语言的语法进行编译。
- 如果函数既有声明和实现，则extern "C" 只能放到声明中
- 使用场景
	1. 在c++文件中调用c文件中的c方法
	2. 为了让自己的c文件即支持c语言调用也支持c++语言的调用可以这样设计对应的.h文件
	```
	#ifndef sum_h
	#define sum_h
	#ifdef __cplusplus
	extern "C" {
	#endif
    	int sum(int a, int b);
	#ifdef __cplusplus
	}
	#endif
	#endif /* sum_h */
	```

### 函数的默认参数
	- 默认参数只能从右边开始
	- 如果函数同时有声明和实现，那么只能在声明中赋值默认参数


### 内联函数
	- 使用inline修饰函数的声明或者实现，可以使其变成内联函数（建议声明和实现都增加inline修饰）
	- 编译器会将函数调用直接展开为函数体代码
		- 这样会减少函数调用的开销，会增大代码体积，不是内联函数调用n次只有一份代码，但是内联函数调用n次就有n分代码
		- 内联函数尽量不要超过10行，过长没必要做内联

	内联函数和宏
	- 都可以减少函数调用的开销
	- 内联函数多了语法检测和函数特性

### #pragma once 
	- #pragma once 可以保证整个文件的内容不背重复包含，较老的比阿尼器不支持，兼容性不好
	- #ifndef、#define、#endif受C/C++标准的支持，不收编译器的任何限制，兼容性好
	- #ifndef、#define、#endif 可以针对一个文件中的部分代码，而#pragma once 只能只对整个文件

### 引用（Refercence）
	```
		int age = 20;
		int &rage = age;
	```
	- 引用相当于变量的别名，所有类型都可以有引用
	- 引用是弱化了的指针，在定义的时候必须初始化，一旦指向了某个变量就不可以再改变

### const 

	- const修饰的变量是常量，定义的时候必须初始化，且以后不能改变
	- const修饰的是右边的部分
	```
		int age = 10;

		// const 修饰的是*p0，所以*p0是常量，p0不是常量
		const int *p0 = &age;
		// 同上
		int const *p1 = &age;
		// const 修饰的是p2， p2是常量，*p2 不是常量
		int * const p2 = &age;
		// p3和*p3都是常量
		const int * const p3 = &age;
		// p4和*p4都是常量
		int const * const p4 = &age;

	```

### 常引用
	- 引用被const修饰后就不能通过引用修改数据了，称为常引用
	- const必须写在&符号的左边，才算是常引用
	- 当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化是的那个变量











































