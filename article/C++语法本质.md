
### C++变成规范
1. 变量名规范
	- 全局变量：g_xxx
	- 成员变量：m_xx
	- 静态变量：s_xx
	- 常量：c_xx
	- 使用驼峰标识

###  函数重载的本质
- c++编译器默认会对符号名（函数名、变量名）进行改编、修饰。重载时会生成多个不同名称的函数；所以支持重载。

###  extern "C" 
- 可以在c++文件中让某个函数按照c语言的语法进行编译。
- 如果函数既有声明和实现，则extern "C" 只能放到声明中
- 使用场景
	1. 在c++文件中调用c文件中的c方法
	2. 为了让自己的c文件即支持c语言调用也支持c++语言的调用可以这样设计对应的.h文件
```
	#ifndef sum_h
	#define sum_h
	#ifdef __cplusplus
	extern "C" {
	#endif
    	int sum(int a, int b);
	#ifdef __cplusplus
	}
	#endif
	#endif /* sum_h */
```

### 函数的默认参数
	- 默认参数只能从右边开始
	- 如果函数同时有声明和实现，那么只能在声明中赋值默认参数


### 内联函数
	- 使用inline修饰函数的声明或者实现，可以使其变成内联函数（建议声明和实现都增加inline修饰）
	- 编译器会将函数调用直接展开为函数体代码
		- 这样会减少函数调用的开销，会增大代码体积，不是内联函数调用n次只有一份代码，但是内联函数调用n次就有n分代码
		- 内联函数尽量不要超过10行，过长没必要做内联

	内联函数和宏
	- 都可以减少函数调用的开销
	- 内联函数多了语法检测和函数特性

### #pragma once 
	- #pragma once 可以保证整个文件的内容不背重复包含，较老的比阿尼器不支持，兼容性不好
	- #ifndef、#define、#endif受C/C++标准的支持，不收编译器的任何限制，兼容性好
	- #ifndef、#define、#endif 可以针对一个文件中的部分代码，而#pragma once 只能只对整个文件

### 引用（Refercence）
```
		int age = 20;
		int &rage = age;
```
	- 引用相当于变量的别名，所有类型都可以有引用
	- 引用是弱化了的指针，在定义的时候必须初始化，一旦指向了某个变量就不可以再改变
	- 一个引用占用一个指针的大小

### const 

	- const修饰的变量是常量，定义的时候必须初始化，且以后不能改变
	- const修饰的是右边的部分
```
		int age = 10;

		// const 修饰的是*p0，所以*p0是常量，p0不是常量
		const int *p0 = &age;
		// 同上
		int const *p1 = &age;
		// const 修饰的是p2， p2是常量，*p2 不是常量
		int * const p2 = &age;
		// p3和*p3都是常量
		const int * const p3 = &age;
		// p4和*p4都是常量
		int const * const p4 = &age;

```

### 常引用
	- 引用被const修饰后就不能通过引用修改数据了，称为常引用
	- const必须写在&符号的左边，才算是常引用
	- 当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化是的那个变量

### 数组的引用
	- int array[] = {10,20,30};
	1. 写法一
	int (&rarray1)[3] = array;
	2. 写法二
	int *const &array2 = array;


### 汇编语言
	[汇编语言的专题](./汇编语言.md)

### 变量地址总结
	- 一个变量的地址值，是它所有字节地址中的最小的那个地址值

### 类
	- C++中使用struct、class来定义一个类
	- struct的默认成员权限是public，class的默认成员权限是private

### this
	- this是指向当前对象的指针
	- 对象在调用成员函数的时候，会自动传入当前对象的内存地址

	-- 思考：可以用this.m_age 来访问成员变量吗？ 不可以！以为this是指针，指针只能通过this->m_age来访问

### 封装
	- 成员变量私有化，提供公共的getter和setter给外界去访问成员变量

### 内存空间的布局
	- 程序运行的时候，系统会给当前程序在内存中分配一块独立的内存。其内存空间一般会有以下几大区域
	1. 代码段：用于存放代码
	2. 数据段：用于存放全局变量
	3. 栈空间：每次函数调用会自动分配一块连续的栈空间，等函数调用完毕后会自动回收这段栈空间
	4. 堆空间：需要主动申请和释放
	- 在程序运行过程，为了能够自由控制内存的生命周期、大小，会经常使用堆空间的内存
	- 堆空间的申请和释放
	1. malloc---- free :申请的内存没有初始化
	2. mew   ---- delete ：申请的内存会被初始化为0
	3. new[] ---- delete[] ：申请的内存会被初始化0
	- memset：memset函数是将较大的数据结构（对象、数组等）内存清零的比较快的方法
```
	Person person;
	person.m_id = 1;
	person.m_age = 10;
	memset(&person,0,sizeof(person));

	Person persons[] = {{1,20},{2,23},{34,34}};
	memset(persons,0,sizeof(persons));

```
### 对象的内存
	- 对象的内存可以存在3中地方
	1. 全局区（数据段）：全局变量
	2. 栈空间： 函数里面的局部函数
	3. 堆空间： 动态申请内存（malloc、new等）

### 构造函数
- 构造函数：也叫构造器，对象创建的时候自动多用，一般用于完成对象的初始化工作
- 特点
	1. 函数名与类同名，无返回值却不能写void，可以有参数，可以重载，可以有多个构造函数
	2. 一旦自定义了构造函数，必须用其中一个自定义的构造函数来初始化对象
	注意：通过maclloc分配的对象不会调用构造函数

#### 注意： 在某些特定的情况下，编译器才会为类生成空的无参的构造函数！不是默认情况下都能生成无参的构造函数
#### 如果自定义了构造函数，除了全局区，其他内存空间的成员变量默认都不会被初始化，需要开发人员手动初始化。

- 对象初始化
```
Person(){
	memset(this,0,sizeof(Person));
}
```

### 析构函数
- 析构函数也叫析构器，在对象销毁的时候自动调用，一般用于完成对象的清理工作
- 特点
	- 函数名以~开头，与类同名，无返回值且不写void，无参，不可重载，有且只有一个析构函数。
- 注意
	- 通过malloc分配的对象free的时候不会调用构造函数
	- 构造函数和析构函数要声明为public，才能被外界正常使用






































